#
# PRE-CONFIGURED PROFILES
#
# This file defines a pre-configured profile with all attributes defined
# and a default rule for each profile type.
# The profiles and rules are named the same as their type.
# For example, the profile of type "http" has the name "http".
# Profiles and rules in this file may be modified but not deleted.
# The file is loaded before bigip.conf.


# LTP classes have been moved to config_base.conf
# as a work-around for tmm doesn't support deleting LTP class

#-------------------------------------------------------------------------------
net rate-shaping drop-policy fred {
    average-packet-size 1024
    fred-max-active 0
    fred-max-drop 100
    fred-min-drop 0
    inverse-weight 128
    max-probability 100
    max-threshold 9216
    min-threshold 3072
    type fred
}
net rate-shaping drop-policy red {
   average-packet-size 1024
   fred-max-active 100
   inverse-weight 512
   max-probability 10
   max-threshold 15
   min-threshold 5
   red-hard-limit 60bytes
   type red
}
net rate-shaping drop-policy tail {
    type tail
}
net rate-shaping queue pfifo {
    type pfifo
}
net rate-shaping queue sfq {
    type sfq
}
#-------------------------------------------------------------------------------
ltm profile certificate-authority certificateauthority {
    ca-file none
    crl-file none
    authenticate-depth 9
    update-crl false
}
ltm profile client-ssl clientssl {
    alert-timeout indefinite
    allow-dynamic-record-sizing disabled
    authenticate once
    authenticate-depth 9
    ca-file none
    cache-size 262144
    cache-timeout 3600
    cert-extension-includes { basic-constraints subject-alternative-name }
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    ciphers DEFAULT
    client-cert-ca none
    crl-file none
    handshake-timeout 10
    key /Common/default.key
    maximum-record-size 16384
    mod-ssl-methods disabled
    mode enabled
    options { dont-insert-empty-fragments no-tlsv1.3 }
    passphrase none
    peer-cert-mode ignore
    renegotiate-max-record-delay indefinite
    renegotiate-period indefinite
    renegotiate-size indefinite
    renegotiation enabled
    secure-renegotiation require
    strict-resume disabled
    unclean-shutdown enabled
    peer-no-renegotiate-timeout 10
}
ltm profile client-ssl clientssl-insecure-compatible {
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    ciphers ALL:!DH:!ADH:!EDH:@SPEED
    defaults-from /Common/clientssl
    inherit-certkeychain true
    renegotiation enabled
    secure-renegotiation request
}
ltm profile client-ssl wom-default-clientssl {
    allow-non-ssl enabled
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
}
ltm profile client-ssl crypto-server-default-clientssl {
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
    ciphers DHE-RSA-AES256-GCM-SHA384
    renegotiate-period 21600
    cache-size 0
}
ltm profile client-ssl clientssl-secure {
    app-service none
    cert /Common/default.crt
    cert-key-chain {
        default {
            cert /Common/default.crt
            key /Common/default.key
        }
    }
    chain none
    ciphers ecdhe:rsa:!sslv3:!rc4:!exp:!des
    defaults-from /Common/clientssl
    inherit-certkeychain true
    key /Common/default.key
    options { no-ssl }
    passphrase none
    renegotiation disabled
}
ltm profile client-ssl splitsession-default-clientssl {
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
}
ltm profile client-ssl clientssl-quic {
    app-service none
    cert /Common/default.crt
    cert-key-chain {
        default {
            cert /Common/default.crt
            key /Common/default.key
        }
    }
    chain none
    cipher-group /Common/f5-quic
    ciphers none
    data-0rtt enabled-with-anti-replay
    defaults-from /Common/clientssl
    inherit-certkeychain true
    key /Common/default.key
    options { dont-insert-empty-fragments no-ssl no-dtls no-tlsv1.1 no-tlsv1.2 no-tlsv1 }
    passphrase none
    renegotiation disabled
    session-ticket enabled
}
ltm profile server-ssl splitsession-default-serverssl {
    defaults-from /Common/serverssl
    cert /Common/default.crt
    key /Common/default.key
    mode enabled
}
ltm profile server-ssl cloud-service-default-ssl {
    defaults-from /Common/serverssl-secure
    authenticate always
    authenticate-depth 9
    authenticate-name *.idservice.net
    peer-cert-mode require
    ca-file /Common/ca-bundle.crt
}
ltm profile server-ssl f5aas-default-ssl {
    defaults-from /Common/serverssl-secure
    authenticate always
    authenticate-depth 9
    authenticate-name *.f5aas.com
    peer-cert-mode require
    ca-file /Common/ca-bundle.crt
}
ltm profile server-ssl shape-api-ssl {
    app-service none
    defaults-from /Common/serverssl
    secure-renegotiation require-strict
    server-name bf.shpapi.com
}
ltm profile dns dns {
    enable-gtm yes
}
ltm profile dns-acceleration dns-acceleration {
}
ltm profile diameter diameter {
    persist-avp Session-Id
}
ltm message-routing diameter profile session diametersession {
}
ltm message-routing diameter profile router diameterrouter {
}
ltm profile request-adapt requestadapt {
}
ltm profile response-adapt responseadapt {
}
ltm profile icap icap {
}
ltm profile connector connector {
}
ltm profile service service {
}
ltm profile qoe qoe {
}
ltm message-routing generic protocol genericmsg {
}
ltm message-routing generic router messagerouter {
}
ltm profile traffic-acceleration traffic-acceleration {
}
ltm profile gtp gtp {
}
ltm profile fix fix {
}
ltm message-routing mqtt profile router mqttrouter {
}
ltm message-routing mqtt profile session mqttsession {
}
ltm message-routing sip profile router siprouter {
    operation-mode load-balancing
}
ltm message-routing sip profile router siprouter-alg {
    defaults-from /Common/siprouter
    operation-mode application-level-gateway
}
ltm message-routing sip profile session sipsession {
    max-msg-size 65535
    generate-response-on-failure disabled
    max-forwards-check enabled
    persistence {
        persist-type session
        persist-key Call-ID
        persist-timeout 180
    }
}
ltm message-routing sip profile session sipsession-alg {
    max-msg-size 65535
    insert-via-header disabled
    honor-via disabled
    generate-response-on-failure disabled
    max-forwards-check disabled
    persistence {
        persist-type none
    }
}
ltm profile fasthttp fasthttp {
    client-close-timeout 5
    connpool-idle-timeout-override 0
    connpool-max-reuse 0
    connpool-max-size 2048
    connpool-min-size 0
    connpool-step 4
    header-insert none
    idle-timeout 300
    insert-xforwarded-for disabled
    layer-7 enabled
    max-header-size 32768
    max-requests 0
    mss-override 0
    reset-on-timeout enabled
    server-close-timeout 5
}
ltm profile fastl4 fastL4 {
    idle-timeout 300
    mss-override 0
    pva-acceleration full
    reassemble-fragments disabled
    reset-on-timeout enabled
}
ltm profile fastl4 security-fastL4 {
    idle-timeout 60
    other-pva-offload-direction server-to-client-only
    pva-offload-dynamic enabled
    rtt-from-client enabled
    tcp-pva-offload-direction server-to-client-only
    tcp-pva-whento-offload establish
}
ltm profile netflow netflow {}
ltm profile fastl4 full-acceleration {
}
ltm profile ftp ftp {}
ltm profile tftp tftp {}
ltm profile ipsecalg ipsecalg {
    idle-timeout 3600
    pending-ike-connection-limit 5
    initial-connection-timeout 3
}
ltm profile html html {
    content-selection { text/html text/xhtml }
}
ltm profile http http {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    oneconnect-status-reuse "200 206"
    proxy-type reverse
    enforcement {
        max-header-count 64
        max-header-size 32768
        pipeline allow
        unknown-method allow
    }
    request-chunking sustain
    response-chunking sustain
}
ltm profile http http-transparent {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type transparent
    enforcement {
        max-header-count 32
        excess-client-headers pass-through
        excess-server-headers pass-through
        max-header-size 16384
        oversize-client-headers pass-through
        oversize-server-headers pass-through
        truncated-redirects enabled
        pipeline allow
        unknown-method allow
    }
    request-chunking sustain
    response-chunking sustain
}
ltm profile http http-explicit {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type explicit
    enforcement {
        max-header-count 64
        max-header-size 32768
        pipeline allow
        unknown-method allow
    }
    request-chunking sustain
    response-chunking sustain
    explicit-proxy {
        route-domain /Common/0
        default-connect-handling deny
        tunnel-name /Common/http-tunnel
        ipv6 no
    }
}
ltm profile httprouter httprouter {
}
ltm profile http2 http2 {
    connection-idle-timeout 300
    insert-header disabled
    insert-header-name X-HTTP2
    enforce-tls-requirements enabled
    include-content-length disabled
    activation-modes { alpn }
    concurrent-streams-per-connection 10
    receive-window 32
    frame-size 2048
    write-size 16384
    header-table-size 4096
}
ltm profile http3 http3 {
    header-table-size 4096
}
ltm profile quic quic {
    bidi-concurrent-streams-per-connection 100
    uni-concurrent-streams-per-connection 10
}
ltm profile websocket websocket {
    masking selective
}
ltm profile splitsessionclient splitsessionclient {
}
ltm profile splitsessionserver splitsessionserver {
}
ltm profile http-proxy-connect http-proxy-connect {
    default-state enabled
}
ltm profile pop3 pop3 {
    activation-mode require
}
ltm profile imap imap {
    activation-mode require
}
ltm profile smtps smtps {
    activation-mode require
}
ltm profile client-ldap clientldap {
    activation-mode require
}
ltm profile server-ldap serverldap {
    activation-mode none
}
ltm profile mqtt mqtt {
}

ltm profile http-compression httpcompression {
    allow-http-10 disabled
    buffer-size 4096
    content-type-exclude none
    content-type-include { text/ "application/(xml|x-javascript)" }
    cpu-saver enabled
    cpu-saver-high 90
    cpu-saver-low 75
    gzip-level 1
    gzip-memory-level 8k
    gzip-window-size 16k
    keep-accept-encoding disabled
    method-prefer gzip
    min-size 1024
    selective disabled
    uri-exclude none
    uri-include { .* }
    vary-header enabled
}
ltm profile http-compression wan-optimized-compression {
    allow-http-10 enabled
    buffer-size 131072
    defaults-from /Common/httpcompression
    gzip-level 1
    gzip-memory-level 16k
    gzip-window-size 64k
    vary-header enabled
}
ltm profile one-connect oneconnect {
    idle-timeout-override disabled
    max-age 86400
    max-reuse 1000
    max-size 10000
    source-mask any
}
ltm profile pptp pptp {
    include-destination-ip disabled
}
ltm profile radius radiusLB {
    clients none
    persist-avp none
}
ltm profile radius radiusLB-subscriber-aware {
    defaults-from /Common/radiusLB
    pem-protocol-profile-radius /Common/_sys_radius_proto_imsi
    subscriber-discovery enabled
}
ltm profile request-log request-log {
    request-logging disabled
    response-logging disabled
}
ltm profile rewrite rewrite {
    client-caching-type cache-css-js
    bypass-list none
    rewrite-list none
    split-tunneling false
    java-ca-file /Common/ca-bundle.crt
    java-sign-key /Common/default.key
    java-signer /Common/default.crt
}
ltm profile ilx ilx {
}
ltm profile rewrite rewrite-portal {
    rewrite-mode portal
    java-ca-file /Common/ca-bundle.crt
    java-sign-key /Common/default.key
    java-signer /Common/default.crt
}
ltm profile rewrite rewrite-uri-translation {
    rewrite-mode uri-translation
}
ltm profile rtsp rtsp {
    idle-timeout 300
}
ltm profile server-ssl serverssl {
    alert-timeout indefinite
    authenticate once
    authenticate-depth 9
    authenticate-name none
    ca-file none
    cache-size 262144
    cache-timeout 3600
    c3d-cert-extension-includes { basic-constraints extended-key-usage key-usage subject-alternative-name }
    cert none
    chain none
    ciphers DEFAULT
    crl-file none
    handshake-timeout 10
    key none
    mod-ssl-methods disabled
    mode enabled
    options { dont-insert-empty-fragments no-tlsv1.3 }
    passphrase none
    peer-cert-mode ignore
    renegotiate-period indefinite
    renegotiate-size indefinite
    renegotiation enabled
    secure-renegotiation require-strict
    strict-resume disabled
    unclean-shutdown enabled
}
ltm profile server-ssl apm-default-serverssl {
    ca-file /Common/ca-bundle.crt
    defaults-from /Common/serverssl
    peer-cert-mode require
    secure-renegotiation request
}
ltm profile server-ssl serverssl-insecure-compatible {
    ciphers !EXPORT:!DH:RSA+RC4:RSA+AES:RSA+DES:RSA+3DES:ECDHE+AES:ECDHE+3DES:@SPEED
    defaults-from /Common/serverssl
    secure-renegotiation request
}
ltm profile server-ssl wom-default-serverssl {
    defaults-from /Common/serverssl
    cert /Common/default.crt
    key /Common/default.key
    mode disabled
}
ltm profile server-ssl crypto-client-default-serverssl {
    defaults-from /Common/serverssl
    ciphers DHE-RSA-AES256-GCM-SHA384
    cache-size 0
}

ltm profile server-ssl /Common/serverssl-secure {
    app-service none
    cipher-group /Common/f5-secure
    ciphers none
    defaults-from /Common/serverssl
    options { no-ssl }
    renegotiation disabled
}

ltm profile server-ssl pcoip-default-serverssl {
    defaults-from /Common/serverssl
    server-name pcoip-default-sni
}
ltm profile sctp sctp {
    idle-timeout 300
    init-max-retries 8
    receive-ordered enabled
    receive-window-size 65535
    reset-on-timeout enabled
    secret default
    send-buffer-size 65536
    send-max-retries 10
    send-partial disabled
    tcp-shutdown disabled
}
ltm profile analytics analytics {
    collect-server-latency enabled
    collect-page-load-time disabled
    collect-url disabled
    collect-ip disabled
    collect-geo disabled
    collect-user-agent disabled
    collect-http-throughput enabled
    collect-response-codes enabled
    collect-methods enabled
    collect-max-tps-and-throughput disabled
    publish-irule-statistics disabled
    collect-user-sessions disabled
    session-timeout 300
    collected-stats-internal-logging enabled
    captured-traffic-internal-logging disabled
    collected-stats-external-logging disabled
    captured-traffic-external-logging disabled
    notification-by-syslog disabled
    notification-by-snmp disabled
    notification-by-email disabled
}
ltm profile tcp-analytics tcp-analytics {
    collected-by-client-side enabled
    collected-by-server-side disabled
    collected-stats-internal-logging enabled
    collect-nexthop disabled
    collect-continent enabled
    collect-region disabled
    collect-city disabled
    collect-post-code disabled
    collect-remote-host-ip disabled
    collect-remote-host-subnet enabled
    collect-country enabled
}
ltm profile classification classification {
    preset /Common/ce
    irule-event on
    app-detection on
    urlcat off
}
ltm profile classification classification_pem {
    preset /Common/ce_pem
    irule-event on
    app-detection on
    urlcat on
}
ltm profile classification classification_apm_swg {
    preset /Common/ce_apm_swg
    irule-event off
    app-detection on
    urlcat off
}
ltm profile sip sip {
    insert-record-route-header disabled
    insert-via-header disabled
    max-size 65535
    secure-via-header disabled
    terminate-on-bye enabled
}
ltm profile statistics stats {
    defaults-from none
    field1 none
    field2 none
    field3 none
    field4 none
    field5 none
    field6 none
    field7 none
    field8 none
    field9 none
    field10 none
    field11 none
    field12 none
    field13 none
    field14 none
    field15 none
    field16 none
    field17 none
    field18 none
    field19 none
    field20 none
    field21 none
    field22 none
    field23 none
    field24 none
    field25 none
    field26 none
    field27 none
    field28 none
    field29 none
    field30 none
    field31 none
    field32 none
}
ltm profile stream stream {
    source none
    target none
}
ltm profile pcp pcp {
    announce-after-failover disabled
    announce-multicast 10
    listening-port 5351      
    map-filter-limit 1
    map-limit-per-client 65535
    map-recycle-delay 60
    max-mapping-lifetime 86400
    min-mapping-lifetime 600
    multicast-port 5350
    peer-oper-allowed disabled
    rule none
    third-party-option disabled
}
ltm profile nat-stats nat-stats {
    level disabled
}
ltm profile tcp f5-tcp-progressive {
    auto-proxy-buffer-size enabled
    auto-receive-window-size enabled
    auto-send-buffer-size enabled
    congestion-control woodside
    defaults-from /Common/tcp
    init-cwnd 16
    init-rwnd 16
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    push-flag auto
    receive-window-size 131072
    send-buffer-size 262144
}
ltm profile tcp f5-tcp-wan {
    congestion-control woodside
    defaults-from /Common/tcp
    delayed-acks disabled
    minimum-rto 500
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    receive-window-size 131072
    send-buffer-size 262144
}
ltm profile tcp f5-tcp-lan {
    defaults-from /Common/tcp
    init-cwnd 16
    init-rwnd 16
    minimum-rto 200
    nagle auto
    proxy-buffer-high 65535
    proxy-buffer-low 32768
    send-buffer-size 65535
}
ltm profile tcp f5-tcp-mobile {
    congestion-control woodside
    defaults-from /Common/tcp
    init-cwnd 16
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    receive-window-size 131072
    send-buffer-size 262144
}
ltm profile tcp tcp {
    abc enabled
    ack-on-push enabled
    auto-proxy-buffer-size disabled
    auto-receive-window-size disabled
    auto-send-buffer-size disabled
    close-wait-timeout 5
    cmetrics-cache enabled
    cmetrics-cache-timeout 0
    congestion-control high-speed
    deferred-accept disabled
    delayed-acks enabled
    delay-window-control disabled
    dsack disabled
    early-retransmit enabled
    ecn enabled
    enhanced-loss-recovery enabled
    fast-open enabled
    fast-open-cookie-expiration 21600
    fin-wait-timeout 5
    fin-wait-2-timeout 300
    idle-timeout 300
    init-cwnd 10
    init-rwnd 10
    ip-tos-to-client 0
    keep-alive-interval 1800
    limited-transmit enabled
    link-qos-to-client 0
    max-retrans 8
    max-segment-size 1460
    md5-signature disabled
    minimum-rto 1000
    mptcp disabled
    nagle disabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 65535
    proxy-buffer-low 32768
    proxy-mss enabled
    proxy-options disabled
    push-flag default
    rate-pace enabled
    rate-pace-max-rate 0
    receive-window-size 65535
    reset-on-timeout enabled
    rexmt-thresh 3
    selective-acks enabled
    selective-nack disabled
    send-buffer-size 131072
    slow-start enabled
    syn-cookie-enable enabled
    syn-cookie-whitelist disabled
    syn-max-retrans 3
    syn-rto-base 3000
    tail-loss-probe enabled
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
    verified-accept disabled
    zero-window-timeout 20000
}
ltm profile tcp tcp-legacy {
    abc enabled
    ack-on-push enabled
    auto-proxy-buffer-size disabled
    auto-receive-window-size disabled
    auto-send-buffer-size disabled
    close-wait-timeout 5
    cmetrics-cache enabled
    cmetrics-cache-timeout 0
    congestion-control high-speed
    defaults-from /Common/tcp
    deferred-accept disabled
    delayed-acks enabled
    delay-window-control disabled
    dsack disabled
    early-retransmit disabled
    ecn disabled
    enhanced-loss-recovery disabled
    fast-open disabled
    fast-open-cookie-expiration 21600
    fin-wait-timeout 5
    fin-wait-2-timeout 300
    idle-timeout 300
    init-cwnd 3
    init-rwnd 3
    ip-tos-to-client 0
    keep-alive-interval 1800
    limited-transmit enabled
    link-qos-to-client 0
    max-retrans 8
    max-segment-size 1460
    md5-signature disabled
    minimum-rto 1000
    mptcp disabled
    nagle disabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 49152
    proxy-buffer-low 32768
    proxy-mss enabled
    proxy-options enabled
    rate-pace disabled
    rate-pace-max-rate 0
    receive-window-size 65535
    reset-on-timeout enabled
    rexmt-thresh 3
    selective-acks enabled
    selective-nack disabled
    send-buffer-size 65535
    slow-start enabled
    syn-cookie-enable enabled
    syn-cookie-whitelist disabled
    syn-max-retrans 3
    syn-rto-base 3000
    tail-loss-probe disabled
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
    verified-accept disabled
    zero-window-timeout 20000
}
ltm profile tcp mptcp-mobile-optimized {
    abc disabled
    congestion-control illinois
    defaults-from /Common/tcp-legacy
    delay-window-control disabled
    delayed-acks disabled
    dsack disabled
    ecn enabled
    init-cwnd 16
    limited-transmit enabled
    mptcp enabled
    nagle enabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    rate-pace enabled
    receive-window-size 131072
    reset-on-timeout disabled
    selective-acks enabled
    send-buffer-size 262144
    slow-start enabled
    syn-cookie-enable disabled
    timestamps enabled
}
ltm profile tcp tcp-mobile-optimized {
    abc disabled
    congestion-control high-speed
    defaults-from /Common/tcp-legacy
    delay-window-control disabled
    delayed-acks disabled
    dsack disabled
    ecn enabled
    init-cwnd 16
    limited-transmit enabled
    nagle enabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    receive-window-size 131072
    reset-on-timeout disabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start enabled
    timestamps enabled
}
ltm profile tcp tcp-lan-optimized {
    ack-on-push enabled
    defaults-from /Common/tcp-legacy
    nagle disabled
    proxy-buffer-high 131072
    proxy-buffer-low 98304
    receive-window-size 65535
    send-buffer-size 65535
    slow-start disabled
}
ltm profile tcp tcp-wan-optimized {
    defaults-from /Common/tcp-legacy
    nagle enabled
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    receive-window-size 65535
    selective-acks enabled
    send-buffer-size 65535
}
ltm profile tcp wom-tcp-lan-optimized {
    cmetrics-cache disabled
    defaults-from /Common/tcp-lan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-mss enabled
    slow-start enabled
}
ltm profile tcp wom-tcp-wan-optimized {
    defaults-from /Common/tcp-wan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-buffer-high 196608
    proxy-buffer-low 131072
    proxy-mss enabled
    receive-window-size 458752
    selective-nack enabled
    send-buffer-size 458752
    slow-start disabled
    zero-window-timeout 300000
    pkt-loss-ignore-burst 8
    pkt-loss-ignore-rate 10000
}
ltm profile tcp splitsession-default-tcp {
    defaults-from /Common/tcp-wan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-buffer-high 196608
    proxy-buffer-low 131072
    proxy-mss enabled
    receive-window-size 458752
    selective-nack enabled
    send-buffer-size 458752
    slow-start disabled
    zero-window-timeout 300000
    pkt-loss-ignore-burst 8
    pkt-loss-ignore-rate 10000
}
ltm profile dhcpv4 dhcpv4 {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    max-hops 4
    ttl-value 0
}
ltm profile dhcpv4 dhcpv4_fwd {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    max-hops 4
    ttl-value 0
    mode forwarding
}
ltm profile dhcpv6 dhcpv6 {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
}
ltm profile dhcpv6 dhcpv6_fwd {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    mode forwarding
}
ltm profile udp udp {
    idle-timeout 60
}
ltm profile udp udp_preserve_ttl {
    idle-timeout 60
    defaults-from /Common/udp
    ip-ttl-mode preserve
}
ltm profile udp udp_decrement_ttl {
    idle-timeout 60
    defaults-from /Common/udp
    ip-ttl-mode decrement
}
ltm profile udp udp_gtm_dns {
    datagram-load-balancing enabled
    defaults-from /Common/udp
    idle-timeout 5
}
ltm profile ipother ipother {
    idle-timeout 60
}

ltm profile map-t mapt {
    defaults-from none
    ip6-prefix ::/48
    ip4-prefix 0.0.0.0/8
    ea-bits-length 32
    port-offset 6
    br-prefix ::/96
}

ltm profile socks socks {
    protocol-versions { socks4 socks4a socks5 }
    default-connect-handling deny
    ipv6 no
    route-domain /Common/0
    tunnel-name /Common/socks-tunnel
}

ltm profile web-acceleration optimized-acceleration {
    cache-object-max-size 67108864
    cache-object-min-size 0
    cache-size 6144
    defaults-from /Common/webacceleration
}
ltm profile web-acceleration optimized-caching {
    cache-max-age 86400
    cache-object-max-size 2000000
    cache-object-min-size 0
    cache-size 10
    defaults-from /Common/webacceleration
}
ltm profile web-acceleration webacceleration {
    cache-aging-rate 9
    cache-client-cache-control-mode all
    cache-insert-age-header enabled
    cache-max-age 3600
    cache-max-entries 10000
    cache-object-max-size 50000
    cache-object-min-size 500
    cache-size 100
    cache-uri-include { .* }
    cache-uri-include-override none
    cache-uri-exclude none
    cache-uri-pinned none
    metadata-cache-max-size 25
}
ltm profile web-security websecurity { }
ltm profile xml xml {}

#-------------------------------------------------------------------------------
#        APM internal virtual profiles.        #
#-------------------------------------------------------------------------------
ltm profile web-acceleration apm-enduser-if-cache {
    cache-max-age 36000
    cache-max-entries 1000
    cache-object-min-size 5
    cache-object-max-size 12000000
    cache-size 50mb
    cache-client-cache-control-mode all
    cache-uri-include { .* }
    cache-uri-include-override none
    defaults-from /Common/webacceleration
}
ltm profile tcp apm-forwarding-client-tcp {
    ack-on-push enabled
    close-wait-timeout 5
    defaults-from /Common/tcp-legacy
    deferred-accept disabled
    delayed-acks enabled
    ecn disabled
    fin-wait-timeout 5
    idle-timeout 300
    keep-alive-interval 60
    limited-transmit enabled
    max-retrans 8
    nagle enabled
    receive-window-size 65535
    reset-on-timeout enabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start disabled
    syn-max-retrans 3
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
}
ltm profile tcp apm-forwarding-server-tcp {
    ack-on-push enabled
    close-wait-timeout 5
    defaults-from /Common/tcp-legacy
    deferred-accept disabled
    delayed-acks enabled
    ecn disabled
    fin-wait-timeout 5
    idle-timeout 300
    keep-alive-interval 60
    limited-transmit enabled
    max-retrans 8
    nagle enabled
    receive-window-size 65535
    reset-on-timeout enabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start disabled
    syn-max-retrans 3
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
}
ltm profile fastl4 apm-forwarding-fastL4 {
    idle-timeout 7200
    defaults-from /Common/fastL4
}
ltm profile service /Common/access-logonpage-protection-service {
    type f5-module
}
ltm profile connector /Common/access-logonpage-protection-connector {
}
#-------------------------------------------------------------------------------

security ssh profile ssh {
    actions {
            default_actions {
            shell-action {
                control allow
                log no
            }
        }
    }
}

security dos profile dos { }

security bot-defense profile bot-defense {
    whitelist {
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-generate-before-access {
    deviceid-mode generate-before-access
    perform-challenge-in-transparent enabled
    dos-attack-strict-mitigation disabled
    api-access-strict-mitigation disabled

    class-overrides {
        "/Common/Malicious Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Suspicious Browser" {
            mitigation {
                action none
            }
        }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Unknown" {
            mitigation {
                action none
            }
        }
        "/Common/Browser" {
            verification {
                action none
            }
        }
        "/Common/Mobile Application" {
            verification {
                action none
            }
        }
    }

    whitelist {
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-generate-after-access {
    deviceid-mode generate-after-access
    perform-challenge-in-transparent enabled
    dos-attack-strict-mitigation disabled
    api-access-strict-mitigation disabled

    class-overrides {
        "/Common/Malicious Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Suspicious Browser" {
            mitigation {
                action none
            }
        }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Unknown" {
            mitigation {
                action none
            }
        }
        "/Common/Browser" {
            verification {
                action none
            }
        }
        "/Common/Mobile Application" {
            verification {
                action none
            }
        }
    }

    whitelist {
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
    }
}

security bot-defense asm-profile bot_defense_asm { }
security bot-defense asm-profile bot_defense_asm_aggregated { }
security http profile http_security { }

# Specify here default values that cannot be set in firewall.xml
security anti-fraud profile antifraud {
    blocking-page {
        response-body "<html><head><title>User Blocked</title></head><body>Your user account has been blocked. Please contact customer support.</body></html>"
        response-headers "HTTP/1.1 200 OK
Cache-Control: no-cache
Pragma: no-cache
Connection: close"
    }
}

security anti-fraud profile /Common/access-logonpage-protection-datasafe {
    defaults-from /Common/antifraud
    description "Access Logon Page protection Datasafe profile"
    app-layer-encryption {
        fail-open disabled
    }
    urls {
        /my.policy* {
            include-query-string enabled
            type wildcard
            login-response {
                status-code 302
                validation enabled
            }
            parameters {
                password {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                username {
                    identify-as-username enabled
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                _F5_challenge {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                _F5_verify_password {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
            }
        }
        /vdesk/agent_logon_page_form.eui* {
            include-query-string enabled
            priority 2
            type wildcard
            login-response {
                status-code 302
                validation enabled
            }
            parameters {
                _F5_challenge {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                _F5_verify_password {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                password {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                username {
                    encrypt enabled
                    identify-as-username enabled
                    obfuscate enabled
                    substitute-value enabled
                }
            }
        }
    }
}

#----------- datasync local profiles -----------#

security datasync local-profile crypt-asm-dosl7 {
    buf-size 10240
    ds-area asm
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
    max-iowait-percent 15
}
security datasync local-profile crypt-fpm {
    buf-size 10240
    ds-area fps
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
    max-iowait-percent 15
}
security datasync local-profile cs-asm-dosl7 {
    buf-size 9437184
    ds-area asm
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 5
    max-iowait-percent 15
}
security datasync local-profile cs-fpm {
    buf-size 16777216
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 10
    max-iowait-percent 15
}
security datasync local-profile static-fpm {
    buf-size 204800
    ds-area fps
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
    max-iowait-percent 15
}
security datasync local-profile rsa {
    buf-size 2097152
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 0
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 50
    offline-until-gen enabled
    rows-bulk 50
    max-iowait-percent 15
}
security datasync local-profile captcha {
    buf-size 5242880
    ds-area asm
    gen-pause-sec 0
    gen-timeout-sec 1800
    keep-conf-files 0
    min-cpu-percent 10
    max-gen-rows infinite
    min-mem-mb 50
    offline-until-gen enabled
    rows-bulk 4
    max-iowait-percent 15
}
security datasync local-profile cs-perm-fpm {
    buf-size 1048576
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 10
    max-iowait-percent 15
}
#------------- profile_persistence -------------#
ltm persistence cookie cookie {
    cookie-name none
    expiration 0
    hash-length 0
    hash-offset 0
    method insert
    mirror disabled
}
ltm persistence dest-addr dest_addr {
    mask none
    mirror disabled
    timeout 180
}
ltm persistence hash hash {
    mirror disabled
    rule none
    timeout 180
}
ltm persistence host host {
    mirror disabled
    timeout 180
}
ltm persistence msrdp msrdp {
    has-session-dir yes
    mirror disabled
    timeout 300
}
ltm persistence sip sip_info {
    mirror disabled
    timeout 180
}
ltm persistence source-addr source_addr {
    map-proxies enabled
    mask none
    mirror disabled
    timeout 180
}
ltm persistence ssl ssl {
    mirror disabled
    timeout 300
}
ltm persistence universal universal {
    mirror disabled
    rule none
    timeout 180
}
#--------- profile_auth
ltm auth profile krbdelegate {
    configuration none
    cookie-key abc123
    cookie-name f5auth
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    type krbdelegate
}
ltm auth profile ldap {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ldap
    type ldap
}
ltm auth profile radius {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_radius
    type radius
}
ltm auth profile ssl_cc_ldap {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_cc_ldap
    type ssl-cc-ldap
}
ltm auth profile ssl_crldp {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_crldp
    type ssl-crldp
}
ltm auth profile ssl_ocsp {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_ocsp
    type ssl-ocsp
}
ltm auth profile tacacs {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_tacacs
    type tacacs
}
#-------------------------------------------------------------------------------
ltm data-group internal aol {
    records {
        64.12.96.0/19 { }
        195.93.16.0/20 { }
        195.93.48.0/22 { }
        195.93.64.0/19 { }
        195.93.96.0/19 { }
        198.81.0.0/22 { }
        198.81.8.0/23 { }
        198.81.16.0/20 { }
        202.67.65.128/25 { }
        205.188.112.0/20 { }
        205.188.146.144/30 { }
        205.188.192.0/20 { }
        205.188.208.0/23 { }
        207.200.112.0/21 { }
    }
    type ip
}
ltm data-group internal images {
    records {
        .bmp { }
        .gif { }
        .jpg { }
    }
    type string
}
ltm data-group internal private_net {
    records {
        10.0.0.0/8 { }
        172.16.0.0/12 { }
        192.168.0.0/16 { }
    }
    type ip
}
ltm data-group internal sys_APM_MS_Office_OFBA_DG {
    description "This internal data-group is used in _sys_APM_MS_Office_OFBA_Support irule"
    records {
        ie_sp_session_sharing_enabled {
            data 0
        }
        ie_sp_session_sharing_inactivity_timeout {
            data 60
        }
        ofba_auth_dialog_size {
            data 800x600
        }
        useragent1 {
            data "microsoft data access internet publishing provider"
        }
        useragent2 {
            data "office protocol discovery"
        }
        useragent3 {
            data "microsoft office"
        }
        useragent4 {
            data non-browser
        }
        useragent5 {
            data "msoffice 12"
        }
        useragent6 {
            data microsoft-webdav-miniredir
        }
        useragent7 {
            data webdav-miniredir
        }
        useragent9 {
            data "ms frontpage 1[23456789]"
        }
        useragent10 {
            data onenote
        }
    }
    type string
}
#-------------------------------------------------------------------------------
ltm alg-log-profile alg_log_profile {
    end-control-channel {
        action enabled
    }
    end-data-channel {
        action enabled
    }
    inbound-transaction {
        action enabled
    }
}
ltm lsn-log-profile lsn_log_profile {
    end-outbound-session {
        action enabled
    }
    end-inbound-session {
        action enabled
    }
    quota-exceeded {
        action enabled
    }
    errors {
        action enabled
    }
}
#-------------------------------------------------------------------------------
ltm rule /Common/_sys_auth_ldap {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(ldap)]} {
            set tmm_auth_sid [AUTH::start pam default_ldap]
            set tmm_auth_http_sids(ldap) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(ldap)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(ldap)] or \
           ($tmm_auth_http_sids(ldap) != [AUTH::last_event_session_id]) or \
           (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "ldap") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }

        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if {[AUTH::status] == 0} {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature ivtbsTt8rheTfPgwLBGpP81b8OdTgGGm1ZBOfZfAvzuT9By32DafRf/n0g7oLZl9yGrqmwcuHmcRsRgAbrvZBlDebWJSRjd2DQoYg2T2+jli0qGy6eNJC8Aw3Du/ldfRxk9vgNKisz5m7SrObMJhp59YVORC6gZMGcvwzRAeI5a1MtNoWFjMIeYULeRQMs+ut/0QKpaCDhQXGyM9Nf9iSaP5V9FdlaT+1X4zCeu0kCAKdxD+5fy2QhR/1B6Yne4lqHLkbIhN22MN9dfPryFGxtW+HryW+hLydl3jLJgfdRltlII9RC/7sNBrrw+1G+pimKbExFUhKlgv3S+AfPyYZA==

}
ltm rule _sys_auth_radius {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(radius)]} {
            set tmm_auth_sid [AUTH::start pam default_radius]
            set tmm_auth_http_sids(radius) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(radius)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(radius)] or \
            ($tmm_auth_http_sids(radius) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "radius") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature IKEOxzIt+/olVVs5ljd6RYYXcLSSPbTHc/N2BSC5FFeNI8xe4T3VpkirN4jkyQOnnySD6JSeDWEekzuatxv2Zj6u0pDBkTk7glhkWQ1qn9qqgSlySyX3vs1t/YA2QvzgW2mnOAwhNebTrGdAz+Rvl0uJlOtH6hiwkqj6AGTU9FtoMfGkxbkjRptdxVcScOs7xtcwN85W+kuP1giU+yslMpF/b5PGJLDua0cnp2UWMVkRF+bJ1WlTluBcd27YIPhZtBkYUZknRYiyZ1mo3+eUI11blhz7mI8XiiAPcL1sVpirCF1PROkD5MrtVKqMdjG2d/CCc5XMVCUF8Wu2CEkThg==

}
ltm rule _sys_auth_ssl_cc_ldap {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_cc_ldap_sid 0
        set tmm_auth_ssl_cc_ldap_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_cc_ldap_done 0
        if {$tmm_auth_ssl_cc_ldap_sid == 0} {
            set tmm_auth_ssl_cc_ldap_sid [AUTH::start pam default_ssl_cc_ldap]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_cc_ldap_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_cc_ldap_sid [SSL::cert 0]
        AUTH::authenticate $tmm_auth_ssl_cc_ldap_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_cc_ldap_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_cc_ldap_sid] and \
            ($tmm_auth_ssl_cc_ldap_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_cc_ldap_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_cc_ldap_done == 0} {
                reject
            }
        }
    }
definition-signature LtRGyLVLmGrOazlR7X/5LJB/TttBDo9XlFr5ATtyQ0jObANtTQ+TFigApDvtqpXZ3vOx9tTbCQ8SUnr9e1AT9Itvat+lanwUcJsYknKCT8/5qVLojcL7gkdONMk4H5gjhsRf6RlfJO2oPSEyYY8MgP4b5m/jj3PuSPzS8H5V0PXYOuxMyJD2dQyhxRNR6huMNYyHE+xX6Gp7QT5Wj2RnDTT84QiPJAOoA8AGQdS2DZYzItkQcynEUD3aNI8zufBoMfRmN+nbiK6CVg8odr49wLCwGOZYQ9EzqJLAcjkQx51ot4KhzaY1Iz2DMZaM52fp/J55U2fYBlLLgWszfY+phg==

}
ltm rule _sys_auth_ssl_ocsp {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_ocsp_sid 0
        set tmm_auth_ssl_ocsp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        if {[SSL::verify_result] != 0} {
            return
        }
        set tmm_auth_ssl_ocsp_done 0
        if {$tmm_auth_ssl_ocsp_sid == 0} {
            set tmm_auth_ssl_ocsp_sid [AUTH::start pam default_ssl_ocsp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_ocsp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_ocsp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_ocsp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_ocsp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_ocsp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_ocsp_sid] and \
            ($tmm_auth_ssl_ocsp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_ocsp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_ocsp_done == 0} {
                reject
            }
        }
    }
definition-signature Oh5q705dyFq3rfV2lDS8dJrRbF/lJlMizOQYAidLVK2OQoOTaWFKl+8UHCRNNqmprz9CZpVHtxKctt40iM5u21F3vy57hCxaRgKZ7IhoQHmFILekQL9RnTVeMJg5m+e7es7h2dCBEIDPHY/+EBFv/YB4s+AEAED+HiNgXtbEKAcbKDvjDE9caeSWe0UbCokMks5V08cNPE88FSu+YjouNf5TkH4tpBXZiiLW6uEX5MS9hayA89JZmg7udLIxJBBCPD5ZIiG+gC7kvbi+xE9oPEffQ3sEDyEhxBZoOIL7HK5oEg0ENOY8HqgDXiCbvOp4daa/aBihMQBjWmjxdRh4tg==

}
ltm rule _sys_auth_ssl_crldp {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_crldp_sid 0
        set tmm_auth_ssl_crldp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_crldp_done 0
        if {$tmm_auth_ssl_crldp_sid == 0} {
            set tmm_auth_ssl_crldp_sid [AUTH::start pam default_ssl_crldp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_crldp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_crldp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_crldp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_crldp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_crldp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_crldp_sid] and \
            ($tmm_auth_ssl_crldp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_crldp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_crldp_done == 0} {
                reject
            }
        }
    }
definition-signature BH/sgHzgcQin7sshuTFXGbdDJFWrfeTKnk1QJMLaKsvs9ip21N5FBbMkKXsR9EeIEMlHJOnfc6sWBDFEA7OqfgqBfVPfOBJdJI9SO+eES7DGpHgkI3Bx3nRJLx/BIkCE2zrw/nWON/bx5SRVxySkw5A498OWMygc4jpZzpi3EqskO4E0zb3LXlcG67D994JJ79aVuwrADm4YIErt+nfITSUWMa6/loBIAS5/kAx0Qn77SaHs9xIyVD4gQ5cjL8xtztWSCi5h3sRf8tB24UZlSLX2zMp+XqpiZ1gAUDFHxA+VZxO68w47OEt+7tkB9XYHxe4c2ICUr0lOx3CL2TcILQ==

}
ltm rule _sys_auth_tacacs {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(tacacs)]} {
            set tmm_auth_sid [AUTH::start pam default_tacacs]
            set tmm_auth_http_sids(tacacs) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(tacacs)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(tacacs)] or \
            ($tmm_auth_http_sids(tacacs) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "tacacs") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature Uq7dIMC0Aws84ull+0BeivuhFi+Va6Sy0gb5wEE2cygYJ8hh9mszXphWSNH8DuMv9TrpORcWJtf+iFYq2M9SmqA9Ld8vWd3Fp3WprEYPqTz92+78kjUbB3arZ4v7o94gHY4YD6DmKl99uYrIWTobWvLyq+VCk6CE7brpz3BJRgAO1+ISN01G0qWBMoDgSy02xkc1yEc2DroFjQd/K54S2jMPrQf1RrJx2iQysNoC7go0qQy+DseLeNovqUE/KOnb6Gzhma77om0kUWte/luEQ4Lb13+7vZjLlemoMPlSFdwYWHWELi775OiulQEcfbY0BQCIkCYH+2JRe2iiBVmAOQ==

}
ltm rule _sys_auth_krbdelegate {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        set thecert ""
        set ckname F5KRBAUTH
        set ckpass abc123
        set authprofiles [PROFILE::list auth]
        # Search the auth profiles for the krbdelegate(7) and grab cookie info
        foreach profname $authprofiles {
            if { [PROFILE::auth $profname type] == 7 } {
                set tmpckname [PROFILE::auth $profname cookie_name]
                set tmpckpass [PROFILE::auth $profname cookie_key]
                if {[PROFILE::auth $profname cookie_name] != "" } {
                    set ckname $tmpckname
                    set ckpass $tmpckpass
                    break
                }
            }
        }
        set seecookie 0
        set insertcookie 0
        # check for the cookie
        if {not [info exists tmm_auth_http_sids(krbdelegate)]} {
            set tmm_auth_sid [AUTH::start pam default_krbdelegate]
            set tmm_auth_http_sids(krbdelegate) $tmm_auth_sid
            AUTH::subscribe $tmm_auth_sid
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(krbdelegate)
        }
        if { [PROFILE::exists clientssl] } {
            set certcmd "SSL::cert 0"
            set thecert [ eval $certcmd ]
        }
        if { $thecert == "" } {
            # if no cert, assume old kerb delegation
            # if there is no Authorization header and no cookie, get one.
            if { ([HTTP::header Authorization] == "") and
                  (not [HTTP::cookie exists $ckname])} {
                HTTP::respond 401 WWW-Authenticate Negotiate
                return
            }
        }
        if {[HTTP::cookie exists $ckname]} {
            set ckval [HTTP::cookie decrypt $ckname $ckpass]
            AUTH::username_credential $tmm_auth_sid "cookie"
            AUTH::password_credential $tmm_auth_sid $ckval
            set seecookie 1
        } else {
            if { $thecert == "" } {
                # Kerberos Delegation - set username
                # Strip off the Negotiate before the base64d goodness
                AUTH::username_credential $tmm_auth_sid [lindex [HTTP::header Authorization] 1]
            }
            else {
                # Protocol Transition - set ttm_auth_sid
                AUTH::username_credential $tmm_auth_sid "krpprottran"
                AUTH::cert_credential $tmm_auth_sid $thecert
            }
            AUTH::password_credential $tmm_auth_sid "xxxx"
        }
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(krbdelegate)] or \
            ($tmm_auth_http_sids(krbdelegate) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "krbdelegate") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
               }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                array set pamout [AUTH::response_data]
                HTTP::header replace Authorization "Negotiate $pamout(krbdelegate:attr:SPNEGO)"
                if {$seecookie == 0} {
                    set insertcookie $pamout(krbdelegate:attr:KRB5CCNAME)
                }
                HTTP::release
            } else {
                HTTP::respond 401 WWW-Authenticate Negotiate "Set-Cookie" "$ckname= ; expires=Wed Dec 31 16:00:00 1969"
            }
        }
    }
    # When the response goes out, if we need to insert a cookie, do it.
    when HTTP_RESPONSE {
        if {$insertcookie != 0} {
            HTTP::cookie insert name $ckname value $insertcookie
            HTTP::cookie encrypt $ckname $ckpass
        }
    }
definition-signature ax5Zk9GEaYsygCFJ/c4SVC/p2nhi9tPNyXKogSH/i+o42+wUmNzts0fiOT0u3zK2PqPEpYtBRzpc84CF6cz8fHYjOrjVuKt/ccWhVIqvSey4sGWV5pYlOWbETi2tFImnxPUn6q9esTmlfXMjuflsx3mJXzw35zEvBhaGMmZ853RVmANRpqP+NJUwFJjrb6rJ+ptlfKMTZPt32/ZRoSXubiWHDZ36eH7bpyisXp/jZiVt/kvhEYDITuFT9BzlTRC+1oiUKvEfxfBvl7f+1d+uORDdPnv2UeUrFWspmVw1THCPCyRfPQvbZaL+FmYh5I9XO0ODhBznKrtdwrLeBuDIuQ==

}
ltm rule _sys_https_redirect {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
       HTTP::redirect https://[getfield [HTTP::host] ":" 1][HTTP::uri]
    }
definition-signature tJY87UPbfpgQ3TPXqXhbCAgqIJhR1MvyFxXLTX/wNqmH+XV51tNkr8HWmv4PBq8hm6w7peLKj88shG+0RiX+yAMU31n6jS9vRcg0VKNPBWLTzu3Ic8abqyyY6XYgkMel+d9Sa8x+vakcuPcAZ0dnICHQiQFePjxYUD0XKwIrbGqQb8vEcU3HHbDaLoMQry4KDnV3s1crFpWXBZBo6esIdzM/s0jYncqZBNdTmIEH3ujEunmo2Jh9MBDhwfGKy1XwCfeeZvzk8b1J+HbRk7W/vbrRUewJZDt+Z13i9u/MbneAL4QXZgtjSxU2nN4GcZjWePUIm7oxc1nz9FGeNva1xg==

}

ltm rule _sys_APM_activesync {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when RULE_INIT {
        set static::actsync_401_http_body   "<html><title>Authentication Failed</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body   "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX       "01490000:7:"
    }
    when HTTP_REQUEST {
        set http_path                       [string tolower [HTTP::path]]
        set f_clientless_mode               0

        if { $http_path == "/microsoft-server-activesync" } {
        }
        elseif { $http_path == "/autodiscover/autodiscover.xml" } {
            set f_auto_discover 1
        }
        else return

        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP  	  1
        }
        # Only allow HTTP Basic Authentication.
        set auth_info_b64enc                ""
        set http_hdr_auth                   [HTTP::header Authorization]
        regexp -nocase {Basic (.*)} $http_hdr_auth match auth_info_b64enc
        if { $auth_info_b64enc == "" } {
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Empty/invalid HTTP Basic Authorization header"
            HTTP::respond 401 content $static::actsync_401_http_body Connection close
            return
        }

        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        # Do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                # Default profile access setting is false
                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                    return
                }
                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                    return
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                }
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
            set MRHSession_cookie ""
            HTTP::cookie remove MRHSession
        }

        set apm_username                    [ string tolower [HTTP::username] ]
        set apm_password                    [HTTP::password]

        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
            binary scan [md5 "$apm_password$"] H* user_hash
        } else {
            binary scan [md5 "$apm_password$src_ip"] H* user_hash
        }
        set user_key {}
        append user_key $apm_username "." $user_hash
        unset user_hash

        set f_insert_clientless_mode    0
        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $apm_cookie != "" } {
                HTTP::cookie insert name MRHSession value $apm_cookie
            } else {
                set f_insert_clientless_mode 1
            }
        } else {
            set f_insert_clientless_mode 1
        }

        if { $f_insert_clientless_mode == 1 } {
            HTTP::header insert "clientless-mode" 1
            HTTP::header insert "username" $apm_username
            HTTP::header insert "password" $apm_password
        }
        unset f_insert_clientless_mode
    }
    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1
            ACCESS::session data set "session.user.activesync" 1
            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                set f_auto_discover 0
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set policy_result [ACCESS::policy result]
        switch $policy_result {
        "allow" {
        }
        "deny" {
            ACCESS::respond 401 content $static::actsync_401_http_body Connection close
            ACCESS::session remove
        }
        default {
            ACCESS::respond 503 content $static::actsync_503_http_body Connection close
            ACCESS::session remove
        }
        }

        unset user_key
    }
definition-signature spIagrH9Xn9IG7rs4q4r0/ANUUJrvYo0d1Gh+2LLA20m7qM6EdVUofs5/pnJYV9OG9t9qkM3531vwT+IdBOX/N2aOPfMnhE4o5qKlMjecBSdLSUikVrWNjxM9kxJgPFTD3CjO2xPbkfghm067JvFCiJh4wcT+zeT2iru/ri8NSRrS+vOYlR4oAFO60N+bXNGB6Z4lLcYYg+lD2+wiZz2I57XuMXmRWANOcK1/HEoM2XPATB8kFZqtZJT5YDodibKmt677sD+HjtzsmgjtxeSNE41urVdZHLvHh9f8KOZjF+Qhl9AZrUgTKaDp8K6QH3BC5nLU/ByrPHD/2tI8z7abA==

}

ltm rule _sys_APM_ExchangeSupport_helper {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    # The purpose of this iRule is for help the main virtual for the timing of the HTTP request retry
    # during the SSO process for OutlookAnywhere protocol request which has a Content-Length value of 1GB.

    when HTTP_REQUEST {
        #  Waiting for the first chunk of data.
        HTTP::collect 1
    }

    when HTTP_REQUEST_DATA {
        # Respond 401 and close the connection once we received the data.
        HTTP::respond 401 WWW-Authenticate NTLM Connection close
    }
definition-signature nR01gptC7P7Tejd6mkHebwHVheXTs9v1yM1Ne0A26dTNbUAu5a/Hw3qngZnmPaHBvPMBMgb1+qm0jogFZ7c2P93pPTfxRWWlpzHJfVhkhxLkCeaqvlKECt9Q0xihCZFu+fTivkNwnqdKTq0HKpnXWv3Z+l0nq5UqOtDNnSJ4qu2ZKGEoBfL7wtc+kOEgQLBSdoYgn8ed2QpScVOuwJjK0HlS6MxLxOBZaHx0Yi7xfmU/G+CDOMD4pCUN9noS8uB+BWHG2Irj7EKdxZUgUlGlVDICKpkr+JHzCPDZ0uTqHU0PmzbIgefKSzS2GR4DkgaeVb3TTwXne/tYfWDIOrvxiw==

}

ltm rule _sys_APM_ExchangeSupport_main {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # Set it into 1 if the backend RPC-over-HTTP handler accepts HTTP Basic Authentication.
        set static::RPC_OVER_HTTP_BKEND_BASIC_AUTH    0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: RPC_OVER_HTTP_BKEND_BASIC_AUTH = $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH"
        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 }  {
            if { $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH == 0 } {
                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Use this virtual $static::ACCESS_SECOND_VIRTUAL_NAME just once. Will be reset back after disconnection."
                    use virtual $static::ACCESS_SECOND_VIRTUAL_NAME
                }
               log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Remove HTTP Auth header"
               HTTP::header remove Authorization
            }
        }
        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
        }
    }

    when HTTP_REQUEST {
        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set src_ip                          [IP::remote_addr]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            # clean up the cookie
            if { $MRHSession_cookie == "" } {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close
                return
            }
            # Do nothing if we have a valid MRHSession cookie.
        }

        set f_release_request           0
        # Optimization for clients which support cookie
        if { $MRHSession_cookie != "" } {
            # Default profile access setting is false
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                set f_release_request 1
            }
            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                set f_release_request 1
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        if { $f_release_request == 0 } {
            set apm_username [ string tolower [HTTP::username]]
            set apm_password [HTTP::password]
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                binary scan [md5 "$apm_password"] H* user_hash
            } else {
                binary scan [md5 "$apm_password$src_ip"] H* user_hash
            }

            set user_key    {}
            append user_key $apm_username "." $user_hash
            unset user_hash

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"
            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $apm_cookie != "" } {
                    HTTP::cookie insert name MRHSession value $apm_cookie
                    set f_release_request 1
                }
            }
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            # This is also going to touch the table entry timer.
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                if { [ info exists f_activesync ] && ($f_activesync == 1) } {
                    # For ActiveSync requests, aggressively starts new session.
                    set f_reqside_set_sess_id    1
                    set f_release_request        1
                } else {
                    set f_sleep_here 1
                }
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set f_clientless_mode 1
                HTTP::cookie remove MRHSession
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { $f_release_request == 0 && $retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when HTTP_RESPONSE {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
            set content_len [ HTTP::header Content-Length ]
            if {  $content_len > 0 } {
                HTTP::collect $content_len
            }
        }
    }
    when HTTP_RESPONSE_DATA {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
            if { [ regsub -line {<AuthPackage>Ntlm</AuthPackage>} [ HTTP::payload ] {<AuthPackage>Basic</AuthPackage>} payload ] != 0 } {
                HTTP::payload replace 0 $content_len $payload
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature ask7ZvjsIV6uvTW96hX6vOlEEBZlb/9PE7FJRiglRmIc+UP3Cb7188DVUorFFTbpGTM/gLe2Qj2OxMP6IEYjNVwJQuD2pQ6Q4lk+dILO5jbTwn2zfuauMIXcO8HpiYow08vQaddT/CxYEsWJwzaakuRgyoJGt/bbeC1u3RdHn4de+3BVBqTMMajKXKzvn13mqH1B/WTs/Z2+ZHw74bKVJ66VXd29tKvD8NQMZGo4oAj2HtCakbxU9b2Tksch4Wmc9RXXiS53cUbk0TK+ZMG3otsUgJnim3BYFqQkBQLxqiChwN5N1Fcp95KOeunJ0qcZDTwuKV4CoRcfMovU0aUOog==

}

ltm rule _sys_APM_ExchangeSupport_OA_BasicAuth {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
        }
    }

    when HTTP_REQUEST {
        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            # clean up the cookie
            if { $MRHSession_cookie == "" } {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                return
            }
            # Do nothing if we have a valid MRHSession cookie.
        }

        set f_release_request           0
        # Optimization for clients which support cookie
        if { $MRHSession_cookie != "" } {
            # Default profile access setting is false
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                set f_release_request 1
            }
            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                set f_release_request 1
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        if { $f_release_request == 0 } {
            set apm_username [string tolower [HTTP::username]]
            set apm_password [HTTP::password]
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                binary scan [md5 "$apm_password"] H* user_hash
            }
            else {
                binary scan [md5 "$apm_password$src_ip"] H* user_hash
            }
            set user_key    "$apm_username.$user_hash"
            unset user_hash

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"
            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $apm_cookie != "" } {
                    HTTP::cookie insert name MRHSession value $apm_cookie
                    set f_release_request 1
                }
            }
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                if { [ info exists f_activesync ] && ($f_activesync == 1) } {
                    # For ActiveSync requests, aggressively starts new session.
                    set f_reqside_set_sess_id    1
                    set f_release_request        1
                } else {
                    set f_sleep_here 1
                }
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT"
                set f_clientless_mode 1
                HTTP::cookie remove MRHSession
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { ($f_release_request == 0) && ($retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE) } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {

            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature H5CYoxBTBYqkK6ZFPeoX68vIv3V9TsbZCwIutNCnPovGN2T8TFPGOUqCX2RL7RhG2y5AAUMPDAat8KDHfy2hQpzENUuW1f0ZmrBg5SCeJdo5FINqqHgwydriQx14njq+FPYTgRYo/j9NxyNzeN9LsiYt6fccBOSzpXqXTfkU0D0ES6QfCsNNoDAsFRBBu9FDT+TjHOz8d2XqRlUZQ/bosGp8NPgU5hGlHkaPbq0tZS90DqmX+CNBcipQHohaJYipyfEryYvHVkC6qet0yKq3jjq0X7CgG3g3WTbXI7U+CMvCb3j1jJlCwdn7b1KWd/ghdKVPgmzTdx+GIoWWLGhelQ==

}

ltm rule _sys_APM_ExchangeSupport_OA_NtlmAuth {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when RULE_INIT {
        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_FAILED                     "policy_failed"
        set static::POLICY_SUCCEED                    "policy_succeed"
        set static::POLICY_DONE_WAIT_SEC              5

        set static::FIRST_BIG_POST_CONTENT_LEN        640000
        set static::POLICY_RESULT_POLL_INTERVAL       100
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  100
        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        set static::USE_NTLM_AUTH                     0
        set static::USE_BASIC_AUTH                    1
        set static::USE_NTLM_BASIC_AUTH               2

        set static::URL_DEFAULT                       0
        set static::URL_RPC_OVER_HTTP                 1
        set static::URL_AUTODISCOVER                  2
        set static::URL_ACTIVE_SYNC                   3
        set static::URL_OFFLINEADDRESSBOOK            4
        set static::URL_EXCHANGEWEBSERVICE            5

        set static::RECVD_AUTH_NONE                   0
        set static::RECVD_AUTH_NTLM                   1
        set static::RECVD_AUTH_BASIC                  2

        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; \
                                                       expires=Thu, 01-Jan-1970 00:00:01 GMT;\
                                                       path=/"

    }

    when HTTP_REQUEST {
        set http_path                       [string tolower [HTTP::path]]
        set url_path                        $static::URL_DEFAULT
        set use_auth                        $static::USE_NTLM_AUTH
        set f_disable_sso                   0

        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            set url_path                    $static::URL_RPC_OVER_HTTP
        }
        "/autodiscover/autodiscover.xml" {
            set url_path                    $static::URL_ACTIVE_SYNC
            # Need to support both NTLM and Basic authentication for this URL
            set use_auth                    $static::USE_NTLM_BASIC_AUTH
        }
        "/microsoft-server-activesync*" {
            set url_path                    $static::URL_ACTIVE_SYNC
            # Use only Basic authentication for this URL
            set use_auth                    $static::USE_BASIC_AUTH
            set f_disable_sso               1
        }
        "/oab*" {
            set url_path                    $static::URL_OFFLINEADDRESSBOOK
        }
        "/ews*" {
            set url_path                    $static::URL_EXCHANGEWEBSERVICE
        }
        default {
            ECA::disable
            return
        }
        }

        if { ! [ info exists f_ntlm_auth_succeed ] } {
            set f_ntlm_auth_succeed         0
        }
        if { ! [ info exists sid_cache ] } {
            set sid_cache                         ""
        }
        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } { 
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method:      $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP:      $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent:  $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri:    $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len:    $http_content_len"

        if { ! [ info exists ECA_METADATA_ARG ] } {
            # Generating argument for ECA::metadata
            # The NTLM configuration name is derived from assigned virtual name with the algorithm as follows:
            # <virtual-fullpath> ::= <folder-path>"/"<virtual-basename> as "/" is the last "/" char.
            # <config-fullpath>  ::= <folder-path>"/" "exch_ntlm" "_" <virtual-basename>
            # e.g.  Let us say the virtual name is "/prod/exch/vs1", The folder path is "/prod/exch/",
            #       then object name will be "/prod/exch/exch_ntlm_vs1".
            set vs_name [virtual name]
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX virtual:     $vs_name"
            set slash_index [ string last / $vs_name ]
            if { $slash_index == -1 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Error: the virtual name does not contain folder information"
                ACCESS::disable
                TCP::close
                return
            }
            set ECA_METADATA_ARG    "select_ntlm:"
            append ECA_METADATA_ARG [ string range $vs_name 0 $slash_index ]
            append ECA_METADATA_ARG "exch_ntlm_"
            append ECA_METADATA_ARG [ string range $vs_name [ expr { $slash_index + 1 } ] end ]
            unset slash_index
            unset vs_name
        }

        if { $use_auth == $static::USE_NTLM_AUTH } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG"
            ECA::enable
            ECA::select $ECA_METADATA_ARG
            return
        } else {
            set recvd_auth                      $static::RECVD_AUTH_NONE
            set http_hdr_auth                   [HTTP::header Authorization]
            set auth_data                       [split $http_hdr_auth " "]
            if { $http_hdr_auth != "" } {
                if { [ llength $auth_data ] == 2 } {
                    set auth_scheme [ lindex $auth_data 0]
                    if { [string equal -nocase $auth_scheme "ntlm" ] == 1 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Recv'd HTTP NTLM Authentication"
                        set recvd_auth          $static::RECVD_AUTH_NTLM
                    } elseif { [ string equal -nocase [ lindex $auth_data 0] "basic" ] == 1 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Recv'd HTTP Basic Authentication"
                        set recvd_auth          $static::RECVD_AUTH_BASIC
                        set user                [string tolower [HTTP::username]]
                        set password            [HTTP::password]
                    }
                }
            }
            if { $use_auth == $static::USE_BASIC_AUTH } {
                if { $recvd_auth == $static::RECVD_AUTH_BASIC } {
                    # Defer the process until later
                } else {
                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate "Basic realm=\"$http_hdr_host\"" \
                                Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                    return
                }
            } elseif { $use_auth == $static::USE_NTLM_BASIC_AUTH } {
                if { ($recvd_auth == $static::RECVD_AUTH_NTLM) || ($f_ntlm_auth_succeed == 1) } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG"
                    ECA::enable
                    ECA::select $ECA_METADATA_ARG
                    return
                } elseif { $recvd_auth == $static::RECVD_AUTH_BASIC } {
                    # Defer the process until later
                } else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Request Authorization: NTLM + Basic"
                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate "Basic realm=\"$http_hdr_host\"" \
                                WWW-Authenticate "NTLM" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                    return
                }
            }

            # Disable NTLM auth
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Disable ECA"
            ECA::disable
            # Disable KCD sso
            set f_disable_sso               1

            if { $MRHSession_cookie != "" } {
                if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                    # Default profile access setting is false
                    if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Release the request"
                        return
                    }
                    elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched. Release the request"
                        return
                    }
                    else {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                    }
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                }

                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }

            set user_key                {}
            if { $PROFILE_RESTRICT_SINGLE_IP == 1 } {
                append user_key                    $src_ip
            }
            append user_key                 $password
            binary scan [md5 $user_key ] H* user_key
            set user_key                    "$user.$user_key"

            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $MRHSession_cookie != "" } {
                    HTTP::cookie remove MRHSession 
                    HTTP::cookie insert name MRHSession value $MRHSession_cookie
                    return
                }
            }

            HTTP::cookie remove MRHSession
            HTTP::header insert "clientless-mode"       1
            HTTP::header insert "username"              $user
            HTTP::header insert "password"              $password
            return
        }
    }

    when ECA_REQUEST_ALLOWED {
        set f_ntlm_auth_succeed                 1

        if { $MRHSession_cookie == "" } {
            # Retrieve from SID cache
            set MRHSession_cookie   $sid_cache
            HTTP::cookie insert name MRHSession value $sid_cache
        }

        if { $MRHSession_cookie != "" } {
            # Destroy session ID cache. This client should not need session ID cache 
            if { ($sid_cache != "") && ($sid_cache != $MRHSession_cookie) } {
                set sid_cache   ""
            }
            if { [ ACCESS::session exists -state_allow $MRHSession_cookie ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                # Default profile access setting is false
                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Release the request"
                    return
                }
                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched. Release the request"
                    return
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                }
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
        }

        set MRHSession  ""
        set sid_cache   ""
        HTTP::cookie remove MRHSession

        # Build user_key
        set    user_key                 {}
        append user_key                 [string tolower [ECA::username]] "@" [ string tolower [ECA::domainname] ]
        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
            append user_key             ":" $src_ip
        }
        append user_key                 ":" [ECA::client_machine_name]

        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $MRHSession_cookie != "" } {
                set sid_cache           $MRHSession_cookie
                HTTP::cookie insert name MRHSession value $MRHSession_cookie
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache"
                return
            }
        }
        unset apm_cookie_list

        set try                         1
        set start_policy_str            $src_ip
        append start_policy_str         [TCP::client_port]

        while { $try <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$try for $http_method $http_uri $http_content_len"

            if { $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                # Wait at below
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX EXEC: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set policy_status [table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT]
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX DONE: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                if { $policy_status == $start_policy_str } {
                    # ACCESS Policy has not started. Start one
                    HTTP::header insert "clientless-mode"    1
                    break
                } elseif { $policy_status == $static::POLICY_SUCCEED } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table is out-of-sync retry"
                    table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
                    continue
                } elseif { $policy_status == $static::POLICY_FAILED } {
                    ACCESS::disable
                    TCP::close
                    return
                }
                # Wait at below
            }

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
            # Touch the entry table
            table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            after  $static::POLICY_RESULT_POLL_INTERVAL

            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $MRHSession_cookie != "" } {
                    set sid_cache           $MRHSession_cookie
                    HTTP::cookie insert name MRHSession value $MRHSession_cookie
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache"
                    return
                }
            }

            incr try
        }

        if { $try >  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [ expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"
            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"

        unset try
        unset start_policy_str
    }

    when ECA_REQUEST_DENIED {
        set f_ntlm_auth_succeed                 0
    }

    when HTTP_RESPONSE_RELEASE {
        if { ! [info exists user_key] } {
            return
        }
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: status:           [HTTP::status]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: Server:           [HTTP::header Server]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: Content-Length:   [HTTP::header Content-Length]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: WWW-Authenticate: [HTTP::header WWW-Authenticate]"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1
        }
    }

    when ACCESS_ACL_ALLOWED {
        if { [ info exists f_disable_sso ] && $f_disable_sso == 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Disable WEBSSO"
            WEBSSO::disable
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        switch $policy_result {
        "allow" {
            set user_key_value          $sid
            set sid_cache               $user_key_value
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"

        }
        "deny" {
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            set f_delete_session  1
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }

        if { $f_ntlm_auth_succeed == 1 } {
            if { $user_key_value != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_SUCCEED"
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_SUCCEED
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC_in table $static::ACCESS_USERKEY_TBLNAME"
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC
            }
        }

        if { $f_delete_session == 1 } {
            ACCESS::session remove
            set f_delete_session 0
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature r8S3kABK0vdxA0Gp40e6xD2LQblbxGAkRljfRv6aqqEPI7CzHdLHa6Own6/2+ao+rqYecm5mqNGUr2StMN1FwrTp8grRVhJFy4G3UmIYm8EGsHQWkQ+4UClXNHJsJYIBEBY0BaLtcf47O46Hsixv51FcdBTsAGmHjttSs2m5iOPXp/vgCY4CgqzCHMHshNLqX23c1y2iehSqpBm9K1YgQIFE0jpIA/k6LcELD0Ck13mTtVSrMWZjelrwTWj2o0FzAfHVDoQRtGzVZDC5bdYgpzeY75vFvx16wUbIy2eGJXHnkvf6D7Mggk5PyZ4UguoQtdiPJhNQU18X9lBDl6xZFQ==

}

ltm rule _sys_APM_Office365_SAML_BasicAuth {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when RULE_INIT {
        set static::ACCESS_LOG_ECP_PREFIX       "014d0002:7: ECP client"
    }
    when HTTP_REQUEST {
        set http_path            [string tolower [HTTP::path]]
        set http_hdr_auth        [HTTP::header Authorization]
        set http_hdr_client_app  [HTTP::header X-MS-Client-Application]
        set http_hdr_client_ip   [HTTP::header X-MS-Forwarded-Client-IP]
        set MRHSession_cookie    [HTTP::cookie value MRHSession]

        if { ($http_path == "/saml/idp/profile/redirectorpost/sso") &&
             ($http_hdr_client_app != "") &&
             ($http_hdr_client_app contains "Microsoft.Exchange") } {
            HTTP::uri "/saml/idp/profile/ecp/sso"
        } elseif { ($http_path != "/saml/idp/profile/ecp/sso")  } {
            return
        }
        set f_saml_ecp_request 1
        unset http_path

        # If MRHSession cookie from client is present, skip further processing.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_ECP_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_ECP_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
            return
        }

        if { ($http_hdr_client_app != "") &&
            ($http_hdr_client_app contains "Microsoft.Exchange") &&
            ($http_hdr_client_ip != "") } {
	    set src_ip $http_hdr_client_ip
	}
        unset http_hdr_client_app
        unset http_hdr_client_ip

        if { ! [ info exists src_ip ] } {
            set src_ip          [IP::remote_addr]
        }

        # Only allow HTTP Basic Authentication.
        if { ($http_hdr_auth == "") || ([ string match -nocase {basic *} $http_hdr_auth ] != 1 ) } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_ECP_PREFIX ECP request does not contain HTTP Basic Authorization header."
            unset http_hdr_auth
            return
        }

        set apm_username        [ string tolower [HTTP::username] ]
        set apm_password        [HTTP::password]

        binary scan [md5 "$apm_password$src_ip"] H* user_hash
        set user_key {}
        append user_key $apm_username "." $user_hash
        unset user_hash

        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $apm_cookie != "" } {
                HTTP::cookie insert name MRHSession value $apm_cookie
            }
        }

        HTTP::header insert "clientless-mode" 1
        HTTP::header insert "username" $apm_username
        HTTP::header insert "password" $apm_password
        unset apm_username
        unset apm_password
        unset http_hdr_auth
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists f_saml_ecp_request ] && $f_saml_ecp_request == 1 } {
            if { [ info exists user_key ] } {
                ACCESS::session data set "session.user.uuid" $user_key
            }
            if { [ info exists  src_ip ] } {
                ACCESS::session data set "session.user.clientip" $src_ip
            }
        }
    }

    when HTTP_RESPONSE {
        if { [ info exists f_saml_ecp_request ] && $f_saml_ecp_request == 1 } {
            unset f_saml_ecp_request
            unset apm_cookie
        }
    }
definition-signature sh9fhU/ivCiEmLpiA6flX8sH3IBE1GgTQ7OpLxOMyU5ccTa9gKTiJz3/4XXZcBOxAmMBCWs8KMtArFBMI32y7QdXYLKDmvuwEEPw4vzVj0SkXzErcOpxouU0eUcn09fFOJ4cL175272f0giLFJZTPHYBRMjKNtm8vWvR65rTj02KCwueArpP5iQUR5yXdymvFB7YbCNxkl/dujJOyecdCBqcjf77l8NsgtOzv6mUHfSDcyVjEKUSGKMMLxb86hkCZODuyKv4oGC6Mgc6IOyDONOJKq7jol/CPF4aoVEqMV86EjxFudlFpGXZ+FoUrboBEkWJnqHoSDd5CMwMZA2TYQ==

}

ltm rule _sys_APM_MS_Office_OFBA_Support {
    nowrite nodelete
# Copyright 2003-2006, 2012, 2016-2017, 2019.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
# Supporting MS-OFBA protocol for native office applications.
# sys_APM_MS_Office_OFBA_DG - iRule data group to customize ofba user agent strings and
#                     few other parameters.
#
# sys_APM_MS_Office_OFBA_DG::useragent - useragent strings are mandatory, 
#       these strings are used to detect OFBA clients. All user agent strings should start
#       with useragent name, for e.g: useragent1, useragent2.. etc.
#
# sys_APM_MS_Office_OFBA_DG::ie_sp_session_sharing_enabled - Parameter to specify whether to enable or
#       disable IE session sharing using persistent cookie named "MRHSOffice".
#       Default is disabled (0), value can be 0 or 1
#     
# sys_APM_MS_Office_OFBA_DG::ie_sp_session_sharing_inactivity_timeout - inactivity timeout value 
#       for the persistent cookie value "MRHSOffice"
#       everytime, the SharePoint site refreshes or gets any response from
#       SharePoint Server.  Value can be any positive value given in seconds.
#       Default value as 60 secs
#
# sys_APM_MS_Office_OFBA_DG::ofba_auth_dialog_size - OFBA dialog browser
#       resolution size given as widthxheight, default 800x600
#
# static::MS_OFBA_ENABLED_CLIENT_TYPE - "ms-ofba-compliant" session variable
#       value that can be used in Access policy Logon agent branch, to add the required authentication
#       for MS OFBA compliant applications.
#
    proc write_log {level message} {

        ACCESS::log $level "\[MSOFBA\] $message"
#       Logs printing for 12.x or older releases
#       log -noname accesscontrol.local1.$level "01490000: \[MSOFBA\] $message"
    }

    proc is_ofba_passthrough_uri {uri} {
        for { set i 0 } { $i < [llength $static::MS_OFBA_PASSTHROUGH_URI_LIST] } { incr i } {
            if { $uri == [lindex $static::MS_OFBA_PASSTHROUGH_URI_LIST $i] } {
                return 1;
            }
        }
        return 0
    }

    when RULE_INIT {
        set static::MS_OFBA_ENABLED_CLIENT_TYPE "ms-ofba-compliant"
        set static::MS_OFBA_AUTH_REQ_URI "/ms-ofba-req-auth"
        set static::MS_OFBA_AUTH_RETURN_URI "/ms-ofba-auth-success"
        set static::MS_OFBA_AUTH_DIALOG_SZ "800x600"
        set static::MS_OFBA_AUTH_SUCCESS_BODY "<html><head><title>User Authenticated</title></head><body><b>Successful OFBA authentication</b></body></html>"
        set static::MS_OFBA_IRULE_DG "sys_APM_MS_Office_OFBA_DG"
        set static::MULTI_DOMAIN_AUTH_RESP_URI "/f5networks-sso-resp"
        set static::MS_OFBA_PASSTHROUGH_URI_LIST {$static::MULTI_DOMAIN_AUTH_RESP_URI "/my.status.eps" "/my.report.eps"}
# sp_persistent_ck: would help to share the session from sharepoint site to
# office applications, if enabled.
        set static::SP_PERSISTENT_CK "MRHSOffice"
        set static::SP_PERSISTENT_CK_TIMEOUT 60
        set static::MS_OFBA_AUTH_TYPE_COOKIE "Auth-Type"
        set static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE "ms-ofba"
    }

    when CLIENT_ACCEPTED {
        if { ![info exists ofba_user_agent_list] } {
# check for config change from datagroup
# since this iRule is read-only, dg config change is done in CLIENT_ACCEPTED rather than in RULE_INIT
            set ofba_user_agent_list [class search -value -all $static::MS_OFBA_IRULE_DG starts_with useragent]
            set f_sp_persistent_ck [class search -value $static::MS_OFBA_IRULE_DG equals ie_sp_session_sharing_enabled]
            set sp_persistent_ck_timeout [class search -value $static::MS_OFBA_IRULE_DG equals ie_sp_session_sharing_inactivity_timeout]
            set ofba_auth_dialog_sz [class search -value $static::MS_OFBA_IRULE_DG equals ofba_auth_dialog_size]
        }
    }

    when HTTP_REQUEST {
# client detection, for ofba client
        set ms_sp_client_type "none"
        set http_path [string tolower [HTTP::path]]
        set http_user_agent [string tolower [HTTP::header "User-Agent"]]
        set session_id [HTTP::cookie value "MRHSession"]
        set f_allow_session 0
        set ms_ofba_auth_cookie ""

        if {[HTTP::header exists "X-FORMS_BASED_AUTH_ACCEPTED"] &&
            (([HTTP::header "X-FORMS_BASED_AUTH_ACCEPTED"] equals "t") ||
             ([HTTP::header "X-FORMS_BASED_AUTH_ACCEPTED"] equals "f"))} {
                set ms_sp_client_type "ms-ofba"
            } elseif { $http_path == $static::MS_OFBA_AUTH_REQ_URI } {
                set ms_sp_client_type "ms-ofba"
            } else {
                if {(!($http_user_agent contains "frontpage") && [string match -nocase {*mozilla*} $http_user_agent]) ||
                    [string match -nocase {*opera*} $http_user_agent]} {
                        set ms_sp_client_type "browser"
                        set ms_ofba_auth_cookie [HTTP::cookie value $static::MS_OFBA_AUTH_TYPE_COOKIE]
                        if { $ms_ofba_auth_cookie == $static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE } {
                            # ofba authentication is still in progress, there may be a case where initial
                            # access denied and user is retrying the session without closing the ofba
                            # initiated browser
                            set ms_sp_client_type "ms-ofba"
                            call write_log debug "Detecting the client type as ms-ofba based auth type cookie"
                        }
                    } else {
                        foreach ofba_user_agent $ofba_user_agent_list {
                            set ofba_user_agent [string trim $ofba_user_agent]
                            if { $ofba_user_agent != "" && [string match -nocase *$ofba_user_agent* $http_user_agent] } {
                                set ms_sp_client_type "ms-ofba"
                                    break
                            }
                        }
                    }
            }

        if { $ms_sp_client_type == "ms-ofba" } {
            call write_log debug "Client-type: (ms-ofba-compliant), http path: ($http_path), user agent: ($http_user_agent)"
        }

        if { $ms_sp_client_type != "ms-ofba" } {
            return
        } elseif { $session_id != "" } {
            if { [ACCESS::session exists -state_allow $session_id] } {
                set f_allow_session 1
                return
            }
        } elseif { $f_sp_persistent_ck == "1" && [HTTP::cookie exists $static::SP_PERSISTENT_CK] } {
            set sp_persistent_ck_value [HTTP::cookie value $static::SP_PERSISTENT_CK]
            if { $sp_persistent_ck_value != "" && [ACCESS::session exists -state_allow $sp_persistent_ck_value] } {
                if {not ([catch {HTTP::cookie insert name "MRHSession" value $sp_persistent_ck_value}]) } {
                    call write_log debug "Restored persistent cookie for sid: ($sp_persistent_ck_value)"
                    set f_allow_session 1
                    return
                } else {
                    call write_log error "Restoring persistent cookie failed for sid: ($sp_persistent_ck_value)"
                    unset sp_persistent_ck_value
                }
            } else {
                unset sp_persistent_ck_value
            }
        }

        if { !($f_allow_session) && $http_path != $static::MS_OFBA_AUTH_REQ_URI } {
            if { $ms_ofba_auth_cookie == $static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE } {
                if { ![call is_ofba_passthrough_uri $http_path]  } {
                    call write_log debug "Redirecting for MS OFBA, based on auth type"
                    HTTP::respond 302 -version 1.1 -noserver Location $static::MS_OFBA_AUTH_REQ_URI
                }
            } else {
                call write_log debug "Responding 403 for MS OFBA initiation"
                if {$ofba_auth_dialog_sz == ""} {
                    set ofba_auth_dialog_sz $static::MS_OFBA_AUTH_DIALOG_SZ
                }
                HTTP::respond 403 -version "1.1" noserver \
                    "X-FORMS_BASED_AUTH_REQUIRED" "https://[HTTP::host]$static::MS_OFBA_AUTH_REQ_URI" \
                    "X-FORMS_BASED_AUTH_RETURN_URL" "https://[HTTP::host]$static::MS_OFBA_AUTH_RETURN_URI" \
                    "X-FORMS_BASED_AUTH_DIALOG_SIZE" $ofba_auth_dialog_sz \
                    "Set-Cookie" "MRHSession=deleted; expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;secure" \
                    "Set-Cookie" "LastMRH_Session=deleted; expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;secure" \
                    "Set-Cookie" "$static::MS_OFBA_AUTH_TYPE_COOKIE=$static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE;path=/;secure;HttpOnly" \
                    "Connection" "Close"
            }
        }
    }

    when HTTP_RESPONSE {
        if { $f_sp_persistent_ck == "1" && ([info exists ms_sp_client_type] && $ms_sp_client_type == "browser") && $session_id != ""} {
            if {$sp_persistent_ck_timeout == ""} {
                set sp_persistent_ck_timeout $static::SP_PERSISTENT_CK_TIMEOUT
            }
            call write_log debug "Set-Cookie for SharePoint persistent cookie: ($static::SP_PERSISTENT_CK) for sid: ($session_id), having timeout: ($sp_persistent_ck_timeout)"

            HTTP::cookie remove $static::SP_PERSISTENT_CK
            HTTP::cookie insert name $static::SP_PERSISTENT_CK value $session_id path "/"
            HTTP::cookie expires $static::SP_PERSISTENT_CK $sp_persistent_ck_timeout relative
            HTTP::cookie secure $static::SP_PERSISTENT_CK enable
            HTTP::cookie httponly $static::SP_PERSISTENT_CK enable

        } elseif { [info exists sp_persistent_ck_value] && $sp_persistent_ck_value ne "" } {
            call write_log debug "Restoring Cookie for MRHSession from persistent cookie: ($sp_persistent_ck_value)"

            HTTP::cookie insert name MRHSession value $sp_persistent_ck_value path "/"
            HTTP::cookie secure MRHSession enable
            unset sp_persistent_ck_value
        }
    }

    when ACCESS_SESSION_STARTED {
        if { ![info exists ms_sp_client_type] || $ms_sp_client_type != "ms-ofba"} {
            return
        }
        ACCESS::session data set session.client.type $static::MS_OFBA_ENABLED_CLIENT_TYPE
    }

    when ACCESS_ACL_ALLOWED {
        switch -glob -- [string tolower [HTTP::path]] $static::MS_OFBA_AUTH_REQ_URI {
            ACCESS::respond 302 noserver Location "https://[HTTP::host]$static::MS_OFBA_AUTH_RETURN_URI"
        } $static::MS_OFBA_AUTH_RETURN_URI {
            ACCESS::respond 200 content $static::MS_OFBA_AUTH_SUCCESS_BODY noserver \
                "Set-Cookie" "$static::MS_OFBA_AUTH_TYPE_COOKIE=deleted;expires=Thu, 01 Jan 1970 00:00:00 GMT;;path=/;secure;HttpOnly"
        } "*/signout.aspx" {
            ACCESS::respond 302 noserver Location "/vdesk/hangup.php3"
                return
        } "/_layouts/accessdenied.aspx" {
            if {[string tolower [URI::query [HTTP::uri] loginasanotheruser]] equals "true" } {
                ACCESS::session remove
                ACCESS::respond 302 noserver Location "/"
                return
            }
        } default {
        }
    }
definition-signature iZGf55ghe/SCmAy8oGgqDG4kibmmFg8ihZSkO7sORsHNAuJQqpPx7PKcqlIYve4AAqLkb8tUEtxgzVV4uXZ73v5t7/DVszSnyeju+HypimEtP2crzjGlxCAxNe2hnOesZkA/6lCrcPah0MjRnQTef8vwfmQ0eKro0guM/TV+8HjyUVH2CLrPVRhEhTfwX/zlkpe6u9ZJTmNNuQVRcKRvlWPnv/6cWYPMlNPI30EMIYK6mapONBv7tY9Ojurr7FddOxG1hGctFh3Z8ufTSo81dUXrsFtba/8TwSbHYBWHs3rRZvmcv1OesnoWrFJ4E3ndmTNM76kXLylbzl7x4a1ZVQ==

}

sys file external-monitor arg_example {
    system-path "/config/monitors/arg_example"
}

sys file external-monitor sample_monitor {
    system-path "/config/monitors/sample_monitor"
}

sys file external-monitor paap_version_monitor {
    system-path "/config/monitors/paap_version_sample"
}

sys file ssl-cert f5-irule.crt {
    system-path "/config/ssl/ssl.crt/f5-irule.crt"
}

sys file ssl-cert /Common/f5-ca-bundle.crt {
    system-path "/config/ssl/ssl.crt/f5-ca-bundle.crt"
}

sys file ssl-cert /Common/default.crt {
    system-path "/config/ssl/ssl.crt/default.crt"
}

sys file ssl-cert /Common/ca-bundle.crt {
    system-path "/config/ssl/ssl.crt/ca-bundle.crt"
}

sys file ssl-key default.key {
    system-path "/config/ssl/ssl.key/default.key"
}

# CA-bundle manager for system default ca-bundle.crt
sys crypto ca-bundle-manager ca-bundle {
    include-url {
        https://cdn.f5.com/product/ca-bundle/blended-bundle.crt
    }
    trusted-ca-bundle /Common/f5-ca-bundle.crt
}

# URL DB Related settings
sys url-db download-schedule urldb {
    start-time 01:00
    end-time 03:00
}

sys crypto allow-key-export {
    value enabled
}

sys crypto acceleration-strategy {
    fixed-ratio 1000
}

#-------------------------------------------------------------------------------
# APM (SAM)
#-------------------------------------------------------------------------------
apm profile access access {
    default-language "en"
    accept-languages {"en"}
}
apm resource remote-desktop citrix-client-bundle default-citrix-client-bundle {
}
apm client-packaging client-packaging {
}

apm profile connectivity connectivity {
    compression-codecs { deflate lzo bzip2 }
    compression enabled
    client-policy {
        connectivity_clientPolicy { }
    }
    citrix-client-bundle /Common/default-citrix-client-bundle
}
apm profile remote-desktop remotedesktop {}
apm profile exchange exchange {
    active-sync-auth-type basic
    active-sync-sso-config none
    active-sync-url "/microsoft-server-activesync*"
    auto-discover-auth-type basic
    auto-discover-sso-config none
    auto-discover-url "/autodiscover/*"
    ntlm-auth-name none
    offline-address-book-auth-type basic
    offline-address-book-sso-config none
    offline-address-book-url "/oab/*"
    rpc-over-http-auth-type basic
    rpc-over-http-sso-config none
    rpc-over-http-url "/rpc/rpcproxy.dll"
    user-agent-pattern-for-utf8 "Android*"
    web-service-auth-type basic
    web-service-sso-config none
    web-service-url "/ews/*"
}
apm profile eca eca {}
apm profile vdi vdi {}

apm apm-avr-config apm-avr-config {
    avr-collect-data true
    avr-sampling true
}

apm profile oauth oauth {
    db-instance /Common/oauthdb
}
apm profile oauthplugin oauthplugin {}

apm profile ping-access pingaccess {}

#-------------------------------------------------------------------------------
# WOM
#-------------------------------------------------------------------------------
wom profile cifs cifs { }
wom profile isession isession {
    compression-codecs { deflate lzo bzip2 }
    compression enabled
}
wom profile isession isession-encrypt {
    data-encryption enabled
}
wom profile isession isession-mapi {
    defaults-from /Common/isession
}
wom profile isession isession-softwoc {
    defaults-from /Common/isession
    deduplication disabled
}
wom profile mapi mapi {
    native-compression disabled
}
wom profile passthru-woc-plugin passthruwocplugin { }

#-------------------------------------------------------------------------------
# IPsec
#-------------------------------------------------------------------------------
net ipsec ike-peer anonymous {
    my-cert-file /Common/default.crt
    my-cert-key-file /Common/default.key
    my-id-type asn1dn
    peers-id-type asn1dn
    state disabled
    verify-cert false
}
sys log-config publisher default-ipsec-log-publisher {
    destinations {
        /Common/local-syslog
    }
}


#-------------------------------------------------------------------------------
# PEM
#-------------------------------------------------------------------------------
pem profile spm spm { }
pem profile subscriber-mgmt subscriber-mgmt { }
pem profile diameter-endpoint diameter-endpoint {
    product-name "BIG-IP"
    gx-session-id-prefix "Gx.BIG-IP.f5net.com"
    gy-session-id-prefix "Gy.BIG-IP.f5net.com"
    sd-session-id-prefix "Sd.BIG-IP.f5net.com"
    msg-retransmit-delay 1500
    msg-max-retransmits 2
    fatal-grace-time {
	time 500
	enabled yes
    }
}
pem profile radius-aaa radiusaaa { }

#-------------------------------------------------------------------------------
# Classification Engine presets
#-------------------------------------------------------------------------------
ltm classification ce ce {
    flow-bundling on
    allow-reclassification on
    cache-results on
}
ltm classification ce ce_pem {
    flow-bundling on
    allow-reclassification on
    cache-results on
}
ltm classification ce ce_apm_swg {
    flow-bundling on
    allow-reclassification on
    cache-results off
}

ltm classification ce ce_afm {
    flow-bundling on
    allow-reclassification off
    cache-results off
}

#-------------------------------------------------------------------------------
# Management Port Firewall
#-------------------------------------------------------------------------------
sys log-config publisher default-mgmt-acl-log-publisher { }

#-------------------------------------------------------------------------------
# API Protection
#-------------------------------------------------------------------------------
api-protection profile apiprotection apiprotection {}

#-------------------------------------------------------------------------------
# Application Cloud Services
#-------------------------------------------------------------------------------
net dns-resolver f5-aws-dns {
    forward-zones {
        shpapi.com {
            nameservers {
                8.8.8.8:53 { }
            }
        }
        amazonaws.com {
            nameservers {
                8.8.8.8:53 { }
            }
        }
        idservice.net {
            nameservers {
                8.8.8.8:53 { }
            }
        }
    }
    route-domain /Common/0        
}

